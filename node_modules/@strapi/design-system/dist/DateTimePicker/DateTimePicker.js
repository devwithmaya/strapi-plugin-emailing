import { jsx as i, jsxs as w } from "react/jsx-runtime";
import Z from "react";
import { getLocalTimeZone as g, parseAbsoluteToLocal as v, toCalendarDateTime as G } from "@internationalized/date";
import $ from "styled-components";
import { DatePickerInput as J } from "../DatePicker/DatePicker.js";
import { useDesignSystem as K } from "../DesignSystemProvider.js";
import { useControllableState as N } from "../hooks/useControllableState.js";
import { useDateFormatter as Q } from "../hooks/useDateFormatter.js";
import { useId as T } from "../hooks/useId.js";
import { TimePickerInput as W } from "../TimePicker/TimePicker.js";
import { Field as X } from "../Field/Field.js";
import { Flex as L } from "../Flex/Flex.js";
import { FieldLabel as Y } from "../Field/FieldLabel.js";
import { VisuallyHidden as S } from "../VisuallyHidden/VisuallyHidden.js";
import { FieldHint as ee } from "../Field/FieldHint.js";
import { FieldError as te } from "../Field/FieldError.js";
const Ce = ({
  /**
   * @preserve
   * @deprecated This is no longer used.
   */
  ariaLabel: b,
  clearLabel: l = "clear",
  dateLabel: u = "Choose date",
  timeLabel: n = "Choose time",
  disabled: I = !1,
  error: f,
  hint: V,
  id: _,
  label: R,
  labelAction: j,
  onChange: C,
  onClear: d,
  name: z,
  required: p = !1,
  /**
   * @preserve
   * @deprecated This is no longer used.
   */
  selectButtonTitle: oe,
  size: x = "M",
  step: B,
  value: h,
  initialDate: F,
  ...H
}) => {
  const k = Z.useRef(null), [t, m] = N({
    defaultProp: F ? s(F, !1) : void 0,
    prop: h ? s(h, !1) : h ?? void 0,
    onChange(e) {
      C && C(e?.toDate(g()));
    }
  }), q = K("DateTimePicker"), A = Q(q.locale, {
    hour: "2-digit",
    minute: "2-digit",
    hour12: !1
  }), a = t ? A.format(t.toDate(g())) : "", E = (e) => {
    let r = e ? s(e) : void 0;
    if (!(r && t && r.compare(t) === 0)) {
      if (a && r) {
        const [c, D] = a.split(":");
        r = r.set({ hour: parseInt(c, 10), minute: parseInt(D, 10) });
      }
      m(r);
    }
  }, M = (e) => {
    if (!e)
      return;
    const [r, c] = e.split(":"), D = t ? t.set({ hour: parseInt(r, 10), minute: parseInt(c, 10) }) : s(/* @__PURE__ */ new Date()).set({ hour: parseInt(r, 10), minute: parseInt(c, 10) });
    m(D);
  }, O = (e) => {
    m(void 0), d && d(e);
  }, U = () => {
    const e = t ? t.set({ hour: 0, minute: 0 }) : s(/* @__PURE__ */ new Date());
    m(e);
  }, o = T(_), y = T(), P = T();
  return i(X, { name: z, as: "fieldset", id: o, "aria-labelledby": o, hint: V, error: f, required: p, children: w(L, { as: "span", direction: "column", alignItems: "stretch", gap: 1, children: [i(Y, { onClick: () => {
    k.current.focus();
  }, as: "legend", id: o, action: j, children: R }), w(L, { flex: "1", gap: 1, children: [i(S, { as: "label", htmlFor: P, children: u }), i(re, { ...H, selectedDate: t?.toDate(g()), onChange: E, error: typeof f == "string", required: p, size: x, onClear: d ? O : void 0, clearLabel: `${l} date`, disabled: I, id: P, ref: k, "aria-describedby": `${o}-hint ${o}-error` }), i(S, { as: "label", htmlFor: y, children: n }), i(ie, { size: x, error: typeof f == "string", value: a, onChange: M, onClear: d && a !== void 0 && a !== "00:00" ? U : void 0, clearLabel: `${l} time`, required: p, disabled: I, step: B, id: y, "aria-describedby": `${o}-hint ${o}-error` })] }), i(ee, {}), i(te, {})] }) });
}, s = (b, l = !0) => {
  const u = b.toISOString();
  let n = v(u);
  return l && (n = n.set({ hour: 0, minute: 0 })), G(n);
}, re = $(J)`
  flex: 1 1 70%;
  min-width: 120px;
`, ie = $(W)`
  flex: 1 1 30%;
  min-width: 120px;
`;
export {
  Ce as DateTimePicker,
  s as convertUTCDateToCalendarDateTime
};
